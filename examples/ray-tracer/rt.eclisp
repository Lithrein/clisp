(%:include ("../../include/macros.eclisph"))
(%:include <stdio.h> <stdlib.h> <math.h> <time.h>)

(import "color")
(import "hittable")
(import "ray")
(import "rt")
(import "utils")
(import "vec3")

;; hit record

(cl-defun hit_sphere (center radius r ht)
  (declare rtype double)
  (declare type (ptr union vec3) center)
  (declare type double radius)
  (declare type (ptr struct ray) r)
  (declare type (ptr struct hit_record) ht)

  (def oc (union vec3) (vec3_sub r->orig *center))
  (def a  double     (vec3_len2 r->dir))
  (def hb double     (vec3_dot oc r->dir))
  (def c  double     (- (vec3_len2 oc) (* radius radius)))
  (def discriminant double (- (* hb hb) (* a c)))
  (def root double (/ (- (+ hb (sqrt discriminant))) a))

  (= ht->t      root)
  (= ht->p      (ray_at (* r) (-> ht t)))
  (= ht->normal (vec3_sdiv (vec3- (-> ht p) (* center)) radius))

  (return (?: (> discriminant 0) root -1.0)))

;; hit record end

(defun ray_color (-> (union vec3) (r (ptr struct ray)) (depth int))
  (def rec      (struct hit_record))
  (def unit_dir (union vec3) (vec3_unit r->dir))
  (def a        double     (/ (+ (. unit_dir y) 1.0) 2))
  (def t double 0.0)

  (if (< depth 0)
    (return (mkvec3 0 0 0)))

  ;; sphere
  (= t (hit_sphere (& (mkvec3 0 0.25 -1)) 0.75 r &rec))
  (when (> t 0.0)
    (def direction (union vec3) (vec3+ rec.normal (random_unit_vector)))
    (return (vec3_mul (mkvec3 0 0.9 0.9) (vec3_smul (ray_color (& (mkray rec.p direction)) (- depth 1)) 0.5))))

  (= t (hit_sphere (& (mkvec3 4 0 -1)) 0.5 r &rec))
  (when (> t 0.0)
    (def direction (union vec3) (vec3+ rec.normal (random_unit_vector)))
    (return (vec3_mul (mkvec3 0.9 0.9 0) (vec3_smul (ray_color (& (mkray rec.p direction)) (- depth 1)) 0.3))))

  (= t (hit_sphere (& (mkvec3 4 0 -3)) 0.5 r &rec))
  (when (> t 0.0)
    (def direction (union vec3) (vec3+ rec.normal (random_unit_vector)))
    (return (vec3_mul (mkvec3 0.7 0.4 0.3) (vec3_smul (ray_color (& (mkray rec.p direction)) (- depth 1)) 0.75))))

  ;; ground
  (= t (hit_sphere (& (mkvec3 0 -1000.5 -1)) 1000 r &rec))
  (when (> t 0.0)
    (def direction (union vec3) (vec3+ rec.normal (random_unit_vector)))
    (return (vec3_smul (ray_color (& (mkray rec.p direction)) (- depth 1)) 0.5)))

  ;; background
  (return (vec3+ (vec3_smul (mkvec3 1.0 1.0 1.0) (- 1.0 a))
                 (vec3_smul (mkvec3 0.5 0.7 1.0) a))))

(defun pixel_sample_square (-> (union vec3) (pixel_delta_u pixel_delta_v (union vec3)))
 (def px double (+ -0.5 (random_double)))
 (def py double (+ -0.5 (random_double)))
 (return (vec3+ (vec3_smul pixel_delta_u px) (vec3_smul pixel_delta_v py))))

(defun get_ray (-> (struct ray) (i j int) (pixel00_loc pixel_delta_u pixel_delta_v camera_center (union vec3)))
  (def pixel_center (union vec3)
       (vec3+ pixel00_loc
              (vec3_smul pixel_delta_u i)
              (vec3_smul pixel_delta_v j)))
  (def pixel_sample (union vec3)
    (vec3+ pixel_center (pixel_sample_square pixel_delta_u pixel_delta_v)))

  (def ray_origin (union vec3) camera_center)
  (def ray_direction (union vec3) (vec3- pixel_sample ray_origin))

  (return (mkray ray_origin ray_direction)))

(local-defun main (-> int void)
  "The entry point."

  (def samples_per_pixel int 500)
  (def max_depth int 50)
  (srand (time NULL))

  ;; image
  (def aspect_ratio double (/ 16.0 9.0))
  (def image_width int 1024)
  (def image_height int (max_i 1 (cast int (/ image_width aspect_ratio))))

  ;; camera
  (def camera_center (union vec3) (mkvec3 -8 3 1))
  (def lookat (union vec3) (mkvec3 0 0 -1))
  (def vup (union vec3) (mkvec3 0 1 0))
  (def vfov double 30.0)
  (def theta double (degrees_to_radians vfov))
  (def h double (tan (/ theta 2)))
  (def focal_length double (vec3_len (vec3- camera_center lookat)))
  (def viewport_height double (* 2 h focal_length))
  (def viewport_width double (* viewport_height
                                  (/ (cast double image_width) image_height)))
  (def u (union vec3))
  (def v (union vec3))
  (def w (union vec3))
  (= w (vec3_unit (vec3- camera_center lookat)))
  (= u (vec3_unit (vec3_cross vup w)))
  (= v (vec3_cross w u))

  ;; u and v are the vectors of the basis of viewport
  (def viewport_u (union vec3) (vec3_smul u viewport_width))
  (def viewport_v (union vec3) (vec3_smul (vec3_minus v) viewport_height))
  ;; delta vectors
  (def pixel_delta_u (union vec3) (vec3_sdiv viewport_u image_width))
  (def pixel_delta_v (union vec3) (vec3_sdiv viewport_v image_height))
  ;; location of the upper left pixel.
  (def viewport_upper_left (union vec3)
       (vec3+ camera_center
         (vec3_minus (vec3+ (vec3_smul w focal_length)
                            (vec3_sdiv viewport_u 2)
                            (vec3_sdiv viewport_v 2)))))

  (def pixel00_loc (union vec3)
       (vec3+ viewport_upper_left
              (vec3_sdiv (vec3+ pixel_delta_u pixel_delta_v) 2)))

  (printf "P3\n%d %d\n255\n" image_width image_height)

  (for (def j int 0) (< j image_height) ++j
    (for (def i int 0) (< i image_width) ++i
      (fprintf stderr "\rScanlines remaining: %d.    " (- image_width j))

      (def pixel_color (union vec3) (mkvec3 0 0 0))
      (for (def sample int 0) (< sample samples_per_pixel) ++sample
        (def r (struct ray) (get_ray i j pixel00_loc pixel_delta_u pixel_delta_v camera_center))
        (= pixel_color (vec3+ pixel_color (ray_color &r max_depth))))

      (write_color stdout pixel_color samples_per_pixel)))

  (fprintf stderr "\rDone.                      \n")
  (return 0))
